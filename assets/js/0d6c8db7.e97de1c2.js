"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([["89480"],{105(n,e,r){r.r(e),r.d(e,{metadata:()=>l,default:()=>h,frontMatter:()=>i,contentTitle:()=>c,toc:()=>o,assets:()=>a});var l=JSON.parse('{"id":"language/rust/ownership","title":"Ownership","description":"Memory Model","source":"@site/content/language/rust/ownership.md","sourceDirName":"language/rust","slug":"/language/rust/ownership","permalink":"/notes/language/rust/ownership","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/rust/ownership.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Rust","permalink":"/notes/tags/rust"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"tags":["Language","Rust"]},"sidebar":"tutorialSidebar","previous":{"title":"Toolchain","permalink":"/notes/language/rust/toolchain"},"next":{"title":"Types","permalink":"/notes/language/rust/types"}}'),t=r(62615),s=r(30416);let i={sidebar_position:2,tags:["Language","Rust"]},c="Ownership",a={},o=[{value:"Memory Model",id:"memory-model",level:2},{value:"Stack",id:"stack",level:3},{value:"Heap",id:"heap",level:3},{value:"Copy Trait",id:"copy-trait",level:2},{value:"Reference",id:"reference",level:2},{value:"Smart Pointer",id:"smart-pointer",level:2},{value:"Box",id:"box",level:3},{value:"Deref Trait",id:"deref-trait",level:3},{value:"Drop Trait",id:"drop-trait",level:3},{value:"Reference Counting",id:"reference-counting",level:3},{value:"Cell and RefCell",id:"cell-and-refcell",level:3},{value:"Circle Reference",id:"circle-reference",level:3},{value:"Phantom",id:"phantom",level:2}];function d(n){let e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(e.header,{children:(0,t.jsx)(e.h1,{id:"ownership",children:"Ownership"})}),"\n",(0,t.jsx)(e.h2,{id:"memory-model",children:"Memory Model"}),"\n",(0,t.jsx)(e.h3,{id:"stack",children:"Stack"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Primitives"}),"\n",(0,t.jsx)(e.li,{children:"Fixed size structs."}),"\n",(0,t.jsx)(e.li,{children:"Fixed size arrays."}),"\n",(0,t.jsx)(e.li,{children:"Pointers and references."}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"heap",children:"Heap"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["Collections:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Arrays."}),"\n",(0,t.jsx)(e.li,{children:"Lists."}),"\n",(0,t.jsx)(e.li,{children:"Strings."}),"\n"]}),"\n"]}),"\n",(0,t.jsxs)(e.li,{children:["Dynamic sized objects:","\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Box."}),"\n",(0,t.jsx)(e.li,{children:"Trait objects."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(e.h2,{id:"copy-trait",children:"Copy Trait"}),"\n",(0,t.jsxs)(e.p,{children:["Copyable type (implement ",(0,t.jsx)(e.code,{children:"Copy"})," trait):"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Integer type."}),"\n",(0,t.jsx)(e.li,{children:"Bool type."}),"\n",(0,t.jsx)(e.li,{children:"Float type."}),"\n",(0,t.jsx)(e.li,{children:"Char type."}),"\n",(0,t.jsxs)(e.li,{children:["Copyable Tuple type, e.g. ",(0,t.jsx)(e.code,{children:"(i32, i32)"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["Reference type (",(0,t.jsx)(e.strong,{children:"borrowing"})," ownership)."]}),"\n"]}),"\n",(0,t.jsx)(e.p,{children:"Most these types store on stack\n(including reference type with vtable)."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    // Primitive type.\n    let a = 5;\n    let b = a;\n\n    // Reference type.\n    let x: &str = "hello, world";\n    let y = x;\n\n    // Deep clone on `non-Copy` type.\n    let s1 = String::from("hello");\n    let s2 = s1.clone();\n\n    // Correct.\n    println!("a = {}, b = {}", a, b);\n    println!("x = {}, y = {}", x, y);\n    println!("s1 = {}, s2 = {}", s1, s2);\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let s1 = String::from("hello");\n    let s2 = s1;\n\n    // Error[E0382]: use of moved value: `s1`.\n    // Move occurs because `s1` has type `std::string::String`,\n    // which does not implement the `Copy` trait.\n    println!("{}, world!", s1);\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"reference",children:"Reference"}),"\n",(0,t.jsx)(e.p,{children:"Borrowing ownership with reference type:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"At same time, only one mutable reference or multiple immutable reference."}),"\n",(0,t.jsx)(e.li,{children:"Reference should be valid (rustc will report dangling reference error)."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let s1 = String::from("hello");\n    let len = calculate_length(&s1);\n    println!("The length of \'{}\' is {}.", s1, len);\n}\n\nfn calculate_length(s: &String) -> usize {\n    s.len()\n    // Leave function without drop `s`,\n    // due to `s` not owner string.\n}\n'})}),"\n",(0,t.jsx)(e.p,{children:"Mutable reference:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"Only one mutable reference for a value in a scope)."}),"\n",(0,t.jsx)(e.li,{children:"Can't mutable borrow an already immutable borrowed value."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    let mut s = String::from("hello");\n    change(&mut s);\n}\n\nfn change(some_string: &mut String) {\n    some_string.push_str(", world");\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n   let mut s = String::from("hello");\n\n    let r1 = &s;\n    let r2 = &s;\n    let r3 = &mut s;\n\n    // Error.\n    println!("{}, {} and {}", r1, r2, r3);\n    // End of r1 and r2 borrowing.\n\n    // Correct.\n    let r4 = &mut s;\n    println!("{}", r4);\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"smart-pointer",children:"Smart Pointer"}),"\n",(0,t.jsx)(e.h3,{id:"box",children:"Box"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Box<T>"})," \u5C06\u4E00\u4E2A\u503C\u5206\u914D\u5230\u5806\u4E0A, \u7136\u540E\u5728\u6808\u4E0A\u4FDD\u7559\u4E00\u4E2A\u667A\u80FD\u6307\u9488\u6307\u5411\u5806\u4E0A\u6570\u636E:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u5B9E\u73B0\u8F6C\u79FB\u6240\u6709\u6743\u65F6\u7684\u96F6\u62F7\u8D1D."}),"\n",(0,t.jsx)(e.li,{children:"\u5C06\u4E0D\u5B9A\u957F\u7C7B\u578B\u8F6C\u6362\u4E3A\u5B9A\u957F\u7C7B\u578B."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'fn main() {\n    // \u5728\u6808\u4E0A\u521B\u5EFA\u4E00\u4E2A\u957F\u5EA6\u4E3A 1000 \u7684\u6570\u7EC4.\n    let arr = [0;1000];\n    // \u5C06 arr \u6240\u6709\u6743\u8F6C\u79FB arr1, \u7531\u4E8E `arr` \u5206\u914D\u5728\u6808\u4E0A, \u56E0\u6B64\u76F4\u63A5\u91CD\u65B0\u6DF1\u62F7\u8D1D\u4E86\u4E00\u4EFD\u6570\u636E.\n    let arr1 = arr;\n\n    // arr \u548C arr1 \u90FD\u62E5\u6709\u5404\u81EA\u7684\u6808\u4E0A\u6570\u7EC4, \u56E0\u6B64\u4E0D\u4F1A\u62A5\u9519.\n    println!("{:?}", arr.len());\n    println!("{:?}", arr1.len());\n\n    // \u5728\u5806\u4E0A\u521B\u5EFA\u4E00\u4E2A\u957F\u5EA6\u4E3A 1000 \u7684\u6570\u7EC4, \u7136\u540E\u4F7F\u7528\u4E00\u4E2A\u667A\u80FD\u6307\u9488\u6307\u5411\u5B83.\n    let arr = Box::new([0;1000]);\n    // \u5C06\u5806\u4E0A\u6570\u7EC4\u7684\u6240\u6709\u6743\u8F6C\u79FB\u7ED9 arr1, \u7531\u4E8E\u6570\u636E\u5728\u5806\u4E0A, \u56E0\u6B64\u4EC5\u4EC5\u62F7\u8D1D\u4E86\u667A\u80FD\u6307\u9488\u7684\u7ED3\u6784\u4F53, \u5E95\u5C42\u6570\u636E\u5E76\u6CA1\u6709\u88AB\u62F7\u8D1D.\n    // \u6240\u6709\u6743\u987A\u5229\u8F6C\u79FB\u7ED9 arr1, arr \u4E0D\u518D\u62E5\u6709\u6240\u6709\u6743.\n    let arr1 = arr;\n    println!("{:?}", arr1.len());\n    // \u7531\u4E8E arr \u4E0D\u518D\u62E5\u6709\u5E95\u5C42\u6570\u7EC4\u7684\u6240\u6709\u6743, \u56E0\u6B64\u4E0B\u9762\u4EE3\u7801\u5C06\u62A5\u9519.\n    // println!("{:?}", arr.len());\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"enum List {\n    Cons(i32, Box<List>),\n    Nil,\n}\n"})}),"\n",(0,t.jsx)(e.h3,{id:"deref-trait",children:"Deref Trait"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"&smart_pointer"}),"\n=> ",(0,t.jsx)(e.code,{children:"smart_pointer.defer()"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"*smart_pointer"}),"\n=> ",(0,t.jsx)(e.code,{children:"*(smart_pointer.defer())"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"smart_pointer.method()"}),"\n=> ",(0,t.jsx)(e.code,{children:"(&smart_pointer).method()"}),"\n=> ",(0,t.jsx)(e.code,{children:"(smart_pointer.defer()).method()"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["When ",(0,t.jsx)(e.code,{children:"T: Deref<Target=U>"}),", then ",(0,t.jsx)(e.code,{children:"&T => &U"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["When ",(0,t.jsx)(e.code,{children:"T: DerefMut<Target=U>"}),", then ",(0,t.jsx)(e.code,{children:"&mut T => &mut U"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:["When ",(0,t.jsx)(e.code,{children:"T: Deref<Target=U>"}),", then ",(0,t.jsx)(e.code,{children:"&mut T => &U"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use core::ops::{self};\nuse crate::str::{self, from_boxed_utf8_unchecked};\nuse crate::vec::Vec;\n\nstruct String {\n    vec: Vec<u8>,\n}\n\nimpl ops::Deref for String {\n    type Target = str;\n\n    fn deref(&self) -> &str {\n        unsafe { str::from_utf8_unchecked(&self.vec) }\n    }\n}\n\nstruct MyBox<T>(T);\n\nimpl<T> MyBox<T> {\n    fn new(x: T) -> MyBox<T> {\n        MyBox(x)\n    }\n}\n\nimpl<T> ops::Deref for MyBox<T> {\n    type Target = T;\n\n    fn deref(&self) -> &Self::Target {\n        &self.0\n    }\n}\n\nfn main() {\n    let x = MyBox::new(5);\n    assert_eq!(5, *x);\n    // => *(x.deref())\n    // => *(&x.0)\n    // => x.0\n\n    let s = MyBox::new(String::from("hello world"));\n    display(&s);\n    // => &MyBox\n    // => MyBox.deref()\n    // => &String\n    // => String.deref()\n    // => &str\n\n    let hello_world = MyBox::new(String::from("hello, world"));\n    let s1: &str = &hello_world;\n    // => &MyBox<String>\n    // => MyBox<String>.deref()\n    // => &String\n    // => String.deref()\n    // => &str\n    let s2: String = hello_world.to_string();\n    // => MyBox<String>.to_string()\n    // => (&MyBox<String>).to_string()\n    // => (MyBox<String>.defer()).to_string()\n    // => (&String).to_string()\n    let ptr: *const u8 = hello_world.as_ptr();\n    // => MyBox<String>.as_ptr()\n    // => (&MyBox<String>).as_ptr()\n    // => (MyBox<String>.defer()).as_ptr()\n    // => (&String).as_ptr()\n    // => (String.defer()).as_ptr()\n    // => (&str).as_ptr()\n}\n\nfn display(s: &str) {\n    println!("{}", s);\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"drop-trait",children:"Drop Trait"}),"\n",(0,t.jsx)(e.p,{children:"Drop order:"}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u53D8\u91CF\u7EA7\u522B, \u6309\u7167\u9006\u5E8F\u7684\u65B9\u5F0F, \u5148\u521B\u5EFA\u7684\u53D8\u91CF\u540E drop."}),"\n",(0,t.jsx)(e.li,{children:"\u7ED3\u6784\u4F53\u5185\u90E8, \u6309\u7167\u987A\u5E8F\u7684\u65B9\u5F0F, \u7ED3\u6784\u4F53\u4E2D\u7684\u5B57\u6BB5\u6309\u7167\u5B9A\u4E49\u4E2D\u7684\u987A\u5E8F\u4F9D\u6B21 drop."}),"\n"]}),"\n",(0,t.jsx)(e.h3,{id:"reference-counting",children:"Reference Counting"}),"\n",(0,t.jsx)(e.p,{children:"\u901A\u8FC7\u5F15\u7528\u8BA1\u6570\u7684\u65B9\u5F0F, \u5141\u8BB8\u4E00\u4E2A\u6570\u636E\u8D44\u6E90\u5728\u540C\u4E00\u65F6\u523B\u62E5\u6709\u591A\u4E2A\u6240\u6709\u8005."}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::rc::Rc;\n\nfn main() {\n    let a = Rc::new(String::from("hello, world"));\n    let b = Rc::clone(&a); // \u590D\u5236\u4E86\u667A\u80FD\u6307\u9488\u5E76\u589E\u52A0\u4E86\u5F15\u7528\u8BA1\u6570, \u5E76\u6CA1\u6709\u514B\u9686\u5E95\u5C42\u6570\u636E.\n    assert_eq!(2, Rc::strong_count(&a));\n    assert_eq!(Rc::strong_count(&a), Rc::strong_count(&b))\n}\n'})}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Rc"}),"/",(0,t.jsx)(e.code,{children:"Arc"})," \u662F\u4E0D\u53EF\u53D8\u5F15\u7528, \u65E0\u6CD5\u4FEE\u6539\u5B83\u6307\u5411\u7684\u503C."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Rc<T>"})," \u662F\u4E00\u4E2A\u667A\u80FD\u6307\u9488, \u5B9E\u73B0\u4E86 ",(0,t.jsx)(e.code,{children:"Deref"})," \u7279\u5F81, \u53EF\u4EE5\u76F4\u63A5\u4F7F\u7528 ",(0,t.jsx)(e.code,{children:"T"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"\u4E00\u65E6\u6700\u540E\u4E00\u4E2A\u62E5\u6709\u8005\u6D88\u5931, \u5219\u8D44\u6E90\u4F1A\u81EA\u52A8\u88AB\u56DE\u6536."}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Arc"}),": Atomic reference counting."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::sync::Arc;\nuse std::thread;\n\nfn main() {\n    let s = Arc::new(String::from("Multiple threads walker"));\n\n    for _ in 0..10 {\n        let s = Arc::clone(&s);\n        let handle = thread::spawn(move || {\n           println!("{}", s)\n        });\n    }\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"cell-and-refcell",children:"Cell and RefCell"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Cell"})," for copyable type."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::cell::Cell;\n\nfn main() {\n    let c = Cell::new("abc");\n    let one = c.get();\n    c.set("xyz");\n    let two = c.get();\n    println!("{}, {}", one, two); // abc, xyz\n}\n'})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::cell::Cell;\n\nfn retain_even(nums: &mut Vec<i32>) {\n    let slice: &[Cell<i32>] = Cell::from_mut(&mut nums[..])\n        .as_slice_of_cells();\n\n    let mut i = 0;\n\n    for num in slice.iter().filter(|num| is_even(num.get())) {\n        slice[i].set(num.get());\n        i += 1;\n    }\n\n    nums.truncate(i);\n}\n"})}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"RefCell"})," for borrowing reference:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsxs)(e.li,{children:["\u5B9E\u73B0\u5185\u90E8\u53EF\u53D8\u6027: \u4E0D\u53EF\u53D8\u503C\u7684\u53EF\u53D8\u501F\u7528.\n",(0,t.jsx)(e.code,{children:"imut_self.refcell_member.borrow_mut().changeMember()"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Rc<RefCell<T>>"}),": \u5B9E\u73B0\u591A\u4E2A\u53EF\u53D8\u6570\u636E\u6240\u6709\u8005."]}),"\n",(0,t.jsxs)(e.li,{children:["\u5B9E\u73B0\u7F16\u8BD1\u671F",(0,t.jsx)(e.strong,{children:"\u53EF\u53D8\u501F\u7528"}),"\u4E0E",(0,t.jsx)(e.strong,{children:"\u4E0D\u53EF\u53D8\u501F\u7528"}),"\u5171\u5B58,\n\u4F46\u4F1A\u5F15\u8D77\u8FD0\u884C\u65F6 ",(0,t.jsx)(e.code,{children:"panic"}),"."]}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::cell::RefCell;\n\nfn main() {\n    let s = RefCell::new(String::from("hello, world"));\n    let s1 = s.borrow();\n    let s2 = s.borrow_mut();\n\n    println!("{}, {}", s1, s2);\n}\n'})}),"\n",(0,t.jsxs)(e.p,{children:["\u901A\u8FC7\u5305\u88F9\u4E00\u5C42 ",(0,t.jsx)(e.code,{children:"RefCell"}),",\n\u5C06\u4E0D\u53EF\u53D8\u501F\u7528 ",(0,t.jsx)(e.code,{children:"&self"})," \u7684\u6210\u5458\u6210\u4E3A\u4E00\u4E2A\u53EF\u53D8\u503C,\n\u7136\u540E\u5B9E\u73B0\u4FEE\u6539:"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::cell::RefCell;\n\npub trait Messenger {\n    fn send(&self, msg: String);\n}\n\npub struct MsgQueue {\n    msg_cache: RefCell<Vec<String>>,\n}\n\nimpl Messenger for MsgQueue {\n    fn send(&self, msg: String) {\n        self.msg_cache.borrow_mut().push(msg)\n    }\n}\n\nfn main() {\n    let mq = MsgQueue {\n        msg_cache: RefCell::new(Vec::new()),\n    };\n    mq.send("hello, world".to_string());\n}\n'})}),"\n",(0,t.jsx)(e.h3,{id:"circle-reference",children:"Circle Reference"}),"\n",(0,t.jsxs)(e.p,{children:[(0,t.jsx)(e.code,{children:"Weak"})," \u901A\u8FC7 ",(0,t.jsx)(e.code,{children:"use std::rc::Weak"})," \u5F15\u5165, \u5177\u6709\u4EE5\u4E0B\u7279\u70B9:"]}),"\n",(0,t.jsxs)(e.ul,{children:["\n",(0,t.jsx)(e.li,{children:"\u53EF\u8BBF\u95EE, \u4F46\u6CA1\u6709\u6240\u6709\u6743, \u4E0D\u589E\u52A0\u5F15\u7528\u8BA1\u6570, \u4E0D\u5F71\u54CD drop."}),"\n",(0,t.jsxs)(e.li,{children:["\u53EF\u7531 ",(0,t.jsx)(e.code,{children:"Rc<T>"})," \u8C03\u7528 ",(0,t.jsx)(e.code,{children:"downgrade"})," \u65B9\u6CD5\u8F6C\u6362\u6210 ",(0,t.jsx)(e.code,{children:"Weak<T>"}),"."]}),"\n",(0,t.jsxs)(e.li,{children:[(0,t.jsx)(e.code,{children:"Weak<T>"})," \u53EF\u4F7F\u7528 ",(0,t.jsx)(e.code,{children:"upgrade"})," \u65B9\u6CD5\u8F6C\u6362\u6210 ",(0,t.jsx)(e.code,{children:"Option<Rc<T>>"}),",\n\u5982\u679C\u8D44\u6E90\u5DF2\u7ECF\u88AB\u91CA\u653E, \u5219 ",(0,t.jsx)(e.code,{children:"Option"})," \u7684\u503C\u662F ",(0,t.jsx)(e.code,{children:"None"}),"."]}),"\n",(0,t.jsx)(e.li,{children:"\u5E38\u7528\u4E8E\u89E3\u51B3\u5FAA\u73AF\u5F15\u7528\u7684\u95EE\u9898."}),"\n"]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\n#[derive(Debug)]\nstruct Node {\n    value: i32,\n    parent: RefCell<Weak<Node>>,\n    children: RefCell<Vec<Rc<Node>>>,\n}\n\nfn main() {\n    let leaf = Rc::new(Node {\n        value: 3,\n        parent: RefCell::new(Weak::new()),\n        children: RefCell::new(vec![]),\n    });\n\n    println!(\n        "leaf strong = {}, weak = {}",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n\n    {\n        let branch = Rc::new(Node {\n            value: 5,\n            parent: RefCell::new(Weak::new()),\n            children: RefCell::new(vec![Rc::clone(&leaf)]),\n        });\n\n        *leaf.parent.borrow_mut() = Rc::downgrade(&branch);\n\n        println!(\n            "branch strong = {}, weak = {}",\n            Rc::strong_count(&branch),\n            Rc::weak_count(&branch),\n        );\n\n        println!(\n            "leaf strong = {}, weak = {}",\n            Rc::strong_count(&leaf),\n            Rc::weak_count(&leaf),\n        );\n    }\n\n    println!("leaf parent = {:?}", leaf.parent.borrow().upgrade());\n    println!(\n        "leaf strong = {}, weak = {}",\n        Rc::strong_count(&leaf),\n        Rc::weak_count(&leaf),\n    );\n}\n'})}),"\n",(0,t.jsx)(e.h2,{id:"phantom",children:"Phantom"}),"\n",(0,t.jsxs)(e.p,{children:["\u865A\u7C7B\u578B/\u5E7D\u7075\u7C7B\u578B\u53C2\u6570\u662F\u4E00\u79CD\u5728",(0,t.jsx)(e.strong,{children:"\u8FD0\u884C\u65F6\u4E0D\u51FA\u73B0"}),",\n\u4EC5\u8FDB\u884C",(0,t.jsx)(e.strong,{children:"\u9759\u6001\u7F16\u8BD1\u68C0\u67E5"}),"\u7684\u7C7B\u578B\u53C2\u6570."]}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::marker::PhantomData;\n\nstruct Iter<'a, T: 'a> {\n    ptr: *const T,\n    end: *const T,\n    _marker: PhantomData<&'a T>,\n}\n\nstruct Vec<T> {\n    data: *const T,\n    len: usize,\n    cap: usize,\n    _marker: PhantomData<T>,\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:"use std::marker::PhantomData;\n\n#[derive(PartialEq)]\nstruct PhantomTuple<A, B>(A, PhantomData<B>);\n\n#[derive(PartialEq)]\nstruct PhantomStruct<A, B> { first: A, phantom: PhantomData<B> }\n\nfn main() {\n    let _tuple1: PhantomTuple<char, f32> = PhantomTuple('Q', PhantomData);\n    let _tuple2: PhantomTuple<char, f64> = PhantomTuple('Q', PhantomData);\n\n    let _struct1: PhantomStruct<char, f32> = PhantomStruct {\n        first: 'Q',\n        phantom: PhantomData,\n    };\n    let _struct2: PhantomStruct<char, f64> = PhantomStruct {\n        first: 'Q',\n        phantom: PhantomData,\n    };\n\n    // \u7F16\u8BD1\u671F\u9519\u8BEF\uFF01\u7C7B\u578B\u4E0D\u5339\u914D\uFF0C\u6240\u4EE5\u8FD9\u4E9B\u503C\u4E0D\u80FD\u591F\u6BD4\u8F83\uFF1A\n    println!(\"_tuple1 == _tuple2 yields: {}\",\n              _tuple1 == _tuple2);\n\n    // \u7F16\u8BD1\u671F\u9519\u8BEF\uFF01\u7C7B\u578B\u4E0D\u5339\u914D\uFF0C\u6240\u4EE5\u8FD9\u4E9B\u503C\u4E0D\u80FD\u591F\u6BD4\u8F83\uFF1A\n    println!(\"_struct1 == _struct2 yields: {}\",\n              _struct1 == _struct2);\n}\n"})}),"\n",(0,t.jsx)(e.pre,{children:(0,t.jsx)(e.code,{className:"language-rust",children:'use std::ops::Add;\nuse std::marker::PhantomData;\n\n#[derive(Debug, Clone, Copy)]\nenum Inch {}\n#[derive(Debug, Clone, Copy)]\nenum Mm {}\n\n#[derive(Debug, Clone, Copy)]\nstruct Length<Unit>(f64, PhantomData<Unit>);\n\nimpl<Unit> Add for Length<Unit> {\n     type Output = Length<Unit>;\n\n    fn add(self, rhs: Length<Unit>) -> Length<Unit> {\n        Length(self.0 + rhs.0, PhantomData)\n    }\n}\n\nfn main() {\n    let one_foot:  Length<Inch> = Length(12.0, PhantomData);\n    let one_meter: Length<Mm>   = Length(1000.0, PhantomData);\n\n    let two_feet = one_foot + one_foot;\n    let two_meters = one_meter + one_meter;\n\n    println!("one foot + one_foot = {:?} in", two_feet.0);\n    println!("one meter + one_meter = {:?} mm", two_meters.0);\n\n    // \u7F16\u8BD1\u671F\u9519\u8BEF: \u7C7B\u578B\u4E0D\u5339\u914D.\n    let compile_error = one_foot + one_meter;\n}\n'})})]})}function h(n={}){let{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,t.jsx)(e,{...n,children:(0,t.jsx)(d,{...n})}):d(n)}},30416(n,e,r){r.d(e,{R:()=>i,x:()=>c});var l=r(59471);let t={},s=l.createContext(t);function i(n){let e=l.useContext(s);return l.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function c(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:i(n.components),l.createElement(s.Provider,{value:e},n.children)}}}]);