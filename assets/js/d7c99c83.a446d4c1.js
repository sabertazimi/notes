"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([["64516"],{4165(e,n,t){t.r(n),t.d(n,{metadata:()=>a,default:()=>c,frontMatter:()=>i,contentTitle:()=>s,toc:()=>d,assets:()=>o});var a=JSON.parse('{"id":"language/haskell/monad","title":"Monad","description":"Writer","source":"@site/content/language/haskell/monad.md","sourceDirName":"language/haskell","slug":"/language/haskell/monad","permalink":"/notes/language/haskell/monad","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/haskell/monad.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Haskell","permalink":"/notes/tags/haskell"},{"inline":true,"label":"Monad","permalink":"/notes/tags/monad"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":7,"frontMatter":{"sidebar_position":7,"tags":["Language","Haskell","Monad"]},"sidebar":"tutorialSidebar","previous":{"title":"Module","permalink":"/notes/language/haskell/module"},"next":{"title":"I/O","permalink":"/notes/language/haskell/io"}}'),l=t(62615),r=t(30416);let i={sidebar_position:7,tags:["Language","Haskell","Monad"]},s="Monad",o={},d=[{value:"Writer",id:"writer",level:2},{value:"Reader",id:"reader",level:2},{value:"State",id:"state",level:2},{value:"Error",id:"error",level:2},{value:"liftM",id:"liftm",level:3},{value:"join",id:"join",level:3},{value:"filterM",id:"filterm",level:3},{value:"foldM",id:"foldm",level:3},{value:"<code>&lt;=&lt;</code> (\u7EC4\u5408\u51FD\u6570)",id:"-\u7EC4\u5408\u51FD\u6570",level:3}];function h(e){let n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",p:"p",pre:"pre",...(0,r.R)(),...e.components};return(0,l.jsxs)(l.Fragment,{children:[(0,l.jsx)(n.header,{children:(0,l.jsx)(n.h1,{id:"monad",children:"Monad"})}),"\n",(0,l.jsx)(n.h2,{id:"writer",children:"Writer"}),"\n",(0,l.jsx)(n.p,{children:"Writer \u53EF\u4EE5\u8BA9\u6211\u4EEC\u5728\u8BA1\u7B97\u7684\u540C\u65F6\u641C\u96C6\u6240\u6709 log \u7EAA\u5F55\uFF0C\u5E76\u6C47\u96C6\u6210\u4E00\u4E2A log \u5E76\u9644\u52A0\u5728\u7ED3\u679C\u4E0A"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-haskell",children:"applyLog :: (a,String) -> (a -> (b,String)) -> (b,String)\napplyLog (x,log) f = let (y,newLog) = f x in (y,log ++ newLog)\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-haskell",children:'ghci> (30, "A freaking platoon.") `applyLog` isBigGang\n(True,"A freaking platoon.Compared gang size to 9")\nghci> ("BathCat","Got outlaw name.") `applyLog` (\\x -> (length x, "Applied length"))\n(7,"Got outlaw name.Applied length")\n'})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-haskell",children:"instance (Monoid w) => Monad (Writer w) where\n    return x = Writer (x, mempty)\n    (Writer (x,v)) >>= f = let (Writer (y, v')) = f x in Writer (y, v `mappend` v')\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-haskell",children:'import Control.Monad.Writer\n\nlogNumber :: Int -> Writer [String] Int\nlogNumber x = Writer (x, ["Got number: " ++ show x])\n\nmultiWithLog :: Writer [String] Int\nmultiWithLog = do\n    a <- logNumber 3\n    b <- logNumber 5\n    return (a*b)\n'})}),"\n",(0,l.jsx)(n.h2,{id:"reader",children:"Reader"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-haskell",children:"instance Monad ((->) r) where\n    return x = _ -> x\n    h >>= f = \\w -> f (h w) w\n"})}),"\n",(0,l.jsx)(n.h2,{id:"state",children:"State"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-haskell",children:"newtype State s a = State { runState :: s -> (a,s) }\n\ninstance Monad (State s) where\n    return x = State $ \\s -> (x,s)\n    (State h) >>= f = State $ \\s -> let (a, newState) = h s\n                                        (State g) = f a\n                                    in  g newState\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-haskell",children:"get = State $ \\s -> (s,s)\nput newState = State $ \\s -> ((),newState)\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-haskell",children:"import Control.Monad.State\n\npop :: State Stack Int\npop = State $ \\(x:xs) -> (x,xs)\n\npush :: Int -> State Stack ()\npush a = State $ \\xs -> ((),a:xs)\n\nstackManipulation :: State Stack Int\nstackManipulation = do\n  push 3\n  a <- pop\n  pop\n"})}),"\n",(0,l.jsx)(n.h2,{id:"error",children:"Error"}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-haskell",children:"instance (Error e) => Monad (Either e) where\n    return x = Right x\n    Right x >>= f = f x\n    Left err >>= f = Left err\n    fail msg = Left (strMsg msg)\n"})}),"\n",(0,l.jsx)(n.pre,{children:(0,l.jsx)(n.code,{className:"language-haskell",children:'ghci> :t strMsg\nstrMsg :: (Error a) => String -> a\nghci> strMsg "boom!" :: String\n"boom!"\n'})}),"\n",(0,l.jsx)(n.h3,{id:"liftm",children:"liftM"}),"\n",(0,l.jsx)(n.h3,{id:"join",children:"join"}),"\n",(0,l.jsx)(n.h3,{id:"filterm",children:"filterM"}),"\n",(0,l.jsx)(n.h3,{id:"foldm",children:"foldM"}),"\n",(0,l.jsxs)(n.h3,{id:"-\u7EC4\u5408\u51FD\u6570",children:[(0,l.jsx)(n.code,{children:"<=<"})," (\u7EC4\u5408\u51FD\u6570)"]})]})}function c(e={}){let{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,l.jsx)(n,{...e,children:(0,l.jsx)(h,{...e})}):h(e)}},30416(e,n,t){t.d(n,{R:()=>i,x:()=>s});var a=t(59471);let l={},r=a.createContext(l);function i(e){let n=a.useContext(r);return a.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function s(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(l):e.components||l:i(e.components),a.createElement(r.Provider,{value:n},e.children)}}}]);