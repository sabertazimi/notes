"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([["34294"],{38608(n,e,l){l.r(e),l.d(e,{metadata:()=>s,default:()=>o,frontMatter:()=>r,contentTitle:()=>d,toc:()=>t,assets:()=>c});var s=JSON.parse('{"id":"language/haskell/class","title":"Class","description":"=>","source":"@site/content/language/haskell/class.md","sourceDirName":"language/haskell","slug":"/language/haskell/class","permalink":"/notes/language/haskell/class","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/haskell/class.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Haskell","permalink":"/notes/tags/haskell"},{"inline":true,"label":"Class","permalink":"/notes/tags/class"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":2,"frontMatter":{"sidebar_position":2,"tags":["Language","Haskell","Class"]},"sidebar":"tutorialSidebar","previous":{"title":"Basics","permalink":"/notes/language/haskell/basics"},"next":{"title":"Data","permalink":"/notes/language/haskell/data"}}'),i=l(62615),a=l(30416);let r={sidebar_position:2,tags:["Language","Haskell","Class"]},d="Class",c={},t=[{value:"=&gt;",id:"",level:2},{value:"Eq",id:"eq",level:2},{value:"Ord",id:"ord",level:2},{value:"Show",id:"show",level:2},{value:"Read",id:"read",level:2},{value:"Enum",id:"enum",level:2},{value:"Bounded",id:"bounded",level:2},{value:"Num",id:"num",level:2},{value:"Integral",id:"integral",level:2},{value:"Floating",id:"floating",level:2},{value:"<em>Functor</em>",id:"functor",level:2},{value:"Control Applicative",id:"control-applicative",level:2},{value:"Maybe",id:"maybe",level:3},{value:"Collection <code>[]</code>",id:"collection-",level:3},{value:"I/O",id:"io",level:3},{value:"ZipList",id:"ziplist",level:3},{value:"Multi Functor",id:"multi-functor",level:3},{value:"\u9AD8\u5EA6\u5C01\u88C5\u51FD\u6570",id:"\u9AD8\u5EA6\u5C01\u88C5\u51FD\u6570",level:3},{value:"Control Monad",id:"control-monad",level:2},{value:"Maybe Monad",id:"maybe-monad",level:3},{value:"List Monad",id:"list-monad",level:3},{value:"MonadPlus",id:"monadplus",level:3},{value:"Monad Algorithms",id:"monad-algorithms",level:3},{value:"\u9A6C\u8D70\u65E5",id:"\u9A6C\u8D70\u65E5",level:4},{value:"Foldable",id:"foldable",level:2},{value:"Data Monoid",id:"data-monoid",level:2},{value:"Customization",id:"customization",level:2}];function h(n){let e={admonition:"admonition",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,a.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(e.header,{children:(0,i.jsx)(e.h1,{id:"class",children:"Class"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> :t (==)\n(==) :: (Eq a) => a -> a -> Bool\n\nghci> :t fromIntegral\nfromIntegral :: (Integral a, Num b) => a -> b\nghci> :info typeClassName\n"})}),"\n",(0,i.jsx)(e.h2,{id:"",children:"=>"}),"\n",(0,i.jsx)(e.p,{children:"=> \u5DE6\u90E8: \u7C7B\u7EA6\u675F(Class Constraint)\n=> \u53F3\u90E8: \u51FD\u6570\u7C7B\u578B(\u53C2\u6570/\u8FD4\u56DE\u503C\u7C7B\u578B),\u5176\u4E2D\u53C2\u6570\u7C7B\u578B\u540C\u5C5E Class"}),"\n",(0,i.jsx)(e.h2,{id:"eq",children:"Eq"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529F\u80FD: \u6210\u5458\u7C7B\u578B\u53EF\u5224\u65AD\u76F8\u7B49\u6027"}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u5927\u90E8\u5206\u57FA\u672C\u7C7B\u578B(\u4E0D\u5305\u542B\u51FD\u6570\u7C7B\u578B)"}),"\n",(0,i.jsx)(e.li,{children:"\u65B9\u6CD5: == \u4E0E /= \u51FD\u6570"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"class Eq a where\n    (==) :: a -> a -> Bool\n    (/=) :: a -> a -> Bool\n    x == y = not (x /= y)\n    x /= y = not (x == y)\n"})}),"\n",(0,i.jsx)(e.h2,{id:"ord",children:"Ord"}),"\n",(0,i.jsx)(e.p,{children:"Ord \u6210\u5458\u5FC5\u4E3A Eq \u6210\u5458: class (Eq a) => Ord a where"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529F\u80FD: \u6210\u5458\u7C7B\u578B\u53EF\u6392\u5E8F"}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u5927\u90E8\u5206\u57FA\u672C\u7C7B\u578B(\u4E0D\u5305\u542B\u51FD\u6570\u7C7B\u578B)"}),"\n",(0,i.jsxs)(e.li,{children:["\u65B9\u6CD5:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"<"})," ",(0,i.jsx)(e.code,{children:">"})," ",(0,i.jsx)(e.code,{children:"<="})," ",(0,i.jsx)(e.code,{children:">="})," \u51FD\u6570"]}),"\n",(0,i.jsx)(e.li,{children:"compare \u51FD\u6570 (Ord a) => a -> a -> Ordering"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"show",children:"Show"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529F\u80FD: \u6210\u5458\u7C7B\u578B\u53EF\u7528\u5B57\u7B26\u4E32\u8868\u793A"}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u5927\u90E8\u5206\u57FA\u672C\u7C7B\u578B(\u4E0D\u5305\u542B\u51FD\u6570\u7C7B\u578B)"}),"\n",(0,i.jsx)(e.li,{children:"\u65B9\u6CD5: show \u51FD\u6570 (Show a) => a -> String"}),"\n"]}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsx)(e.p,{children:"\u7ED3\u5408 Read, \u53EF\u7528\u4E8E\u5B57\u7B26\u4E32\u4E0E\u6570\u503C\u4E4B\u95F4\u7684\u8F6C\u5316"})}),"\n",(0,i.jsx)(e.h2,{id:"read",children:"Read"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529F\u80FD: \u53EF\u4EE5\u5C06\u5B57\u4E32\u8F6C\u4E3A Read \u67D0\u6210\u5458\u7C7B\u578B"}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u5927\u90E8\u5206\u57FA\u672C\u7C7B\u578B(\u4E0D\u5305\u542B\u51FD\u6570\u7C7B\u578B)"}),"\n",(0,i.jsx)(e.li,{children:"\u65B9\u6CD5: read \u51FD\u6570 (Read a) => String -> a"}),"\n"]}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsx)(e.p,{children:"\u7ED3\u5408 Show, \u53EF\u7528\u4E8E\u5B57\u7B26\u4E32\u4E0E\u6570\u503C\u4E4B\u95F4\u7684\u8F6C\u5316"})}),"\n",(0,i.jsx)(e.h2,{id:"enum",children:"Enum"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u529F\u80FD: \u8FDE\u7EED\u6027(\u53EF\u679A\u4E3E), \u5176\u6210\u5458\u7C7B\u578B\u53EF\u7528\u4E8E",(0,i.jsx)(e.strong,{children:"Range"}),"\u4E2D"]}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: () Bool Char Ordering Int Integer Float Double"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"[Thursday .. Sunday]\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> succ Monday\nTuesday\nghci> pred Saturday\nFriday\n"})}),"\n",(0,i.jsx)(e.h2,{id:"bounded",children:"Bounded"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529F\u80FD: \u6210\u5458\u7C7B\u578B\u5177\u6709\u4E0A\u4E0B\u9650"}),"\n",(0,i.jsxs)(e.li,{children:["\u65B9\u6CD5: minBound/maxBound \u51FD\u6570 (Bounded a) => a ",(0,i.jsx)(e.em,{children:"\u65E0\u53C2\u591A\u6001\u5E38\u91CF/\u5B9A\u4E49"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> minBound :: Day\nMonday\nghci> maxBound :: Day\nSunday\n"})}),"\n",(0,i.jsx)(e.h2,{id:"num",children:"Num"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529F\u80FD: \u6210\u5458\u7C7B\u578B\u5177\u6709\u6570\u5B57\u7279\u5F81."}),"\n",(0,i.jsxs)(e.li,{children:["\u6210\u5458: \u5B9E\u6570 \u6574\u6570 (",(0,i.jsx)(e.code,{children:"Int"}),"/",(0,i.jsx)(e.code,{children:"Integer"}),"/",(0,i.jsx)(e.code,{children:"Float"}),"/",(0,i.jsx)(e.code,{children:"Double"}),")."]}),"\n",(0,i.jsxs)(e.li,{children:["\u65B9\u6CD5: ",(0,i.jsx)(e.code,{children:"+"}),"/",(0,i.jsx)(e.code,{children:"-"}),"/",(0,i.jsx)(e.code,{children:"*"}),"/",(0,i.jsx)(e.code,{children:"abs"})," \u51FD\u6570."]}),"\n",(0,i.jsx)(e.li,{children:"\u5B9E\u4F8B: \u6240\u6709\u6570\u5B57\u90FD\u662F\u591A\u6001\u5E38\u91CF/\u5B9A\u4E49(\u53EF\u89C6\u4E3A\u51FD\u6570)."}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> :t 20\n20 :: (Num t) => t\n"})}),"\n",(0,i.jsx)(e.h2,{id:"integral",children:"Integral"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529F\u80FD: \u6210\u5458\u7C7B\u578B\u5177\u6709\u6570\u5B57\u7279\u5F81"}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u6574\u578B - Int Integer"}),"\n"]}),"\n",(0,i.jsx)(e.h2,{id:"floating",children:"Floating"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u529F\u80FD: \u6210\u5458\u7C7B\u578B\u5177\u6709\u6570\u5B57\u7279\u5F81"}),"\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u6D6E\u70B9\u578B - Float Double"}),"\n"]}),"\n",(0,i.jsxs)(e.table,{children:[(0,i.jsx)(e.thead,{children:(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"TypeClass"}),(0,i.jsx)(e.th,{style:{textAlign:"left"},children:"Method Feature"})]})}),(0,i.jsxs)(e.tbody,{children:[(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Functor"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"f a + (a -> b) -> f b"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Applicative"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"f a + f (a -> b) -> f b"})]}),(0,i.jsxs)(e.tr,{children:[(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"Monad"}),(0,i.jsx)(e.td,{style:{textAlign:"left"},children:"m a + (a -> m b) -> m b"})]})]})]}),"\n",(0,i.jsx)(e.h2,{id:"functor",children:(0,i.jsx)(e.em,{children:"Functor"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u6210\u5458: Maybe a, [], Either a, IO","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u6210\u5458 kind \u5FC5\u987B\u4E3A ",(0,i.jsx)(e.code,{children:"* -> *"})]}),"\n",(0,i.jsxs)(e.li,{children:["f ",(0,i.jsx)(e.em,{children:"\u4E00\u5143\u7C7B\u578B\u6784\u9020\u7B26(type constructor)"})]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["\u5FC5\u987B\u9075\u5B88\u51C6\u5219:","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"fmap id = id"}),"\n",(0,i.jsx)(e.li,{children:"fmap (f . g) F = fmap f (fmap g F)"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> :info Functor\nclass Functor (f :: * -> *) where\n    fmap :: (a -> b) -> f a -> f b\n    ($) :: a -> f b -> f a\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Functor [] where\n    fmap = map\n\ninstance Functor Maybe where\n    fmap f (Just x) = Just (f x)\n    fmap f Nothing = Nothing\n\ninstance Functor (Either a) where\n    fmap f (Right x) = Right (f x)\n    fmap f (Left x) = Left x\n\ninstance Functor IO where\n    fmap f action = do\n        result <- action\n        return (f result)\n"})}),"\n",(0,i.jsx)(e.h2,{id:"control-applicative",children:"Control Applicative"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u6210\u5458: ",(0,i.jsx)(e.code,{children:"f :: * -> *"})," ",(0,i.jsx)(e.em,{children:"\u4E00\u5143\u7C7B\u578B\u6784\u9020\u7B26 (Type Constructor)"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.code,{children:"<*>"}),": \u53C2\u6570\u4E3A 2 \u4E2A functor \u5B9E\u4F8B, \u5176\u4E2D\u4E00\u4E2A\u5305\u542B\u4E00\u4E2A\u51FD\u6570."]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"(<$>) :: (Functor f) => (a -> b) -> f a -> f b\nf <$> x = fmap f x\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u4F5C\u7528: \u53EF\u4EE5\u7528\u5355\u4E00\u4E00\u4E2A\u51FD\u6570\u64CD\u4F5C\u591A\u4E2A functor"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"class (Functor f) => Applicative f where\n    pure :: a -> f a\n    (<*>) :: f (a -> b) -> f a -> f b\n"})}),"\n",(0,i.jsx)(e.h3,{id:"maybe",children:"Maybe"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Applicative Maybe where\n    pure = Just\n    Nothing <*> _ = Nothing\n    (Just f) <*> something = fmap f something\n"})}),"\n",(0,i.jsxs)(e.h3,{id:"collection-",children:["Collection ",(0,i.jsx)(e.code,{children:"[]"})]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Applicative [] where\n    pure x = [x]\n    fs <*> xs = [f x | f <- fs, x <- xs]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"io",children:"I/O"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Applicative IO where\n    pure = return\n    a <*> b = do\n        f <- a\n        x <- b\n        return (f x)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"ziplist",children:"ZipList"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Applicative ZipList where\n        pure x = ZipList (repeat x)\n        ZipList fs <*> ZipList xs = ZipList (zipWith (\\f x -> f x) fs xs)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"multi-functor",children:"Multi Functor"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> pure (+) <*> Just 3 <*> Just 5\nJust 8\nghci> pure (+) <*> Just 3 <*> Nothing\nNothing\nghci> pure (+) <*> Nothing <*> Just 5\nNothing\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> (*) <$> [2,5,10] <*> [8,10,11]\n[16,20,22,40,50,55,80,100,110]\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"myAction :: IO String\nmyAction = (++) <$> getLine <*> getLine\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> getZipList $ max <$> ZipList [1,2,3,4,5,3] <*> ZipList [5,3,1,2]\n[5,3,3,4]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"\u9AD8\u5EA6\u5C01\u88C5\u51FD\u6570",children:"\u9AD8\u5EA6\u5C01\u88C5\u51FD\u6570"}),"\n",(0,i.jsxs)(e.p,{children:[(0,i.jsx)(e.code,{children:"liftA2"}),", \u5BF9\u4E24\u4E2A applicative \u8FD0\u7528\u4E8C\u5143\u51FD\u6570:"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"liftA2 :: (Applicative f) => (a -> b -> c) -> f a -> f b -> f c\nliftA2 f a b = f <$> a <*> b\n\nghci> liftA2 (:) (Just 3) (Just [4])\nJust [3,4]\nghci> (:) <$> Just 3 <*> Just [4]\nJust [3,4]\n"})}),"\n",(0,i.jsx)(e.h2,{id:"control-monad",children:"Control Monad"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u6210\u5458: \u7C7B\u578B\u6784\u9020\u7B26(type constructor)"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"class Monad m where\n    return :: a -> m a\n\n{- bind -}(>>=) :: m a -> (a -> m b) -> m b\n\n    (>>) :: m a -> m b -> m b\n    x >> y = x >>= _ -> y\n\n    fail :: String -> m a\n    fail msg = error msg\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u7279\u6027: \u5141\u8BB8\u8FD4\u56DE\u503C\u4E4B\u95F4\u5177\u6709\u5F39\u6027\u4EA4\u4E92"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"{- \u5F53\u51FA\u73B0\u5F02\u5E38\u540E,\u4E4B\u540E\u6240\u6709\u7684\u503C\u90FD\u53D8\u4E3ANothing -}\nghci> return (0,0) >>= landRight 2 >>= landLeft 2 >>= landRight 2\nJust (2,4)\nghci> return (0,0) >>= landLeft 1 >>= landRight 4\n  \\ >>= landLeft (-1) >>= landRight (-2)\nNothing\n"})}),"\n",(0,i.jsx)(e.p,{children:"Monad Laws:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["return \u6EE1\u8DB3 Left identity: ",(0,i.jsx)(e.code,{children:"return x >>= f \u7B49\u4E8E f x"})]}),"\n",(0,i.jsxs)(e.li,{children:["return \u6EE1\u8DB3 right identity: ",(0,i.jsx)(e.code,{children:"m >>= return \u7B49\u4E8E m"})]}),"\n",(0,i.jsxs)(e.li,{children:["Associativity: \u7ED3\u5408\u5F8B ",(0,i.jsx)(e.code,{children:"(m >>= f) >>= g \u7B49\u4E8E m >>= (\\x -> f x >>= g)"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:'ghci> return 3 >>= (\\x -> Just (x+100000))\nJust 100003\nghci> (\\x -> Just (x+100000)) 3\nJust 100003\n\nghci> Just "move on up" >>= (\\x -> return x)\nJust "move on up"\nghci> [1,2,3,4] >>= (\\x -> return x)\n[1,2,3,4]\nghci> putStrLn "Wah!" >>= (\\x -> return x)\nWah!\n\n(<=<) :: (Monad m) => (b -> m c) -> (a -> m b) -> (a -> m c)\nf <=< g = (\\x -> g x >>= f)\nghci> let f x = [x,-x]\nghci> let g x = [x*3,x*2]\nghci> let h = f <=< g\nghci> h 3\n[9,-9,6,-6]\n'})}),"\n",(0,i.jsx)(e.h3,{id:"maybe-monad",children:"Maybe Monad"}),"\n",(0,i.jsx)(e.p,{children:"\u5177\u6709\u5931\u8D25\u53EF\u80FD\u6027\u7684 context \u5C01\u88C5,\u7075\u6D3B\u5904\u7406\u5F02\u5E38(\u8FD4\u56DE\u503C\u4E3A Nothing)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"applyMaybe :: Maybe a -> (a -> Maybe b) -> Maybe b\napplyMaybe Nothing f  = Nothing\napplyMaybe (Just x) f = f x\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Monad Maybe where\n    return x = Just x\n    Nothing >>= f = Nothing\n    Just x >>= f  = f x\n    fail _ = Nothing\n"})}),"\n",(0,i.jsx)(e.p,{children:"do \u8868\u793A\u6CD5:"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u5728 do expression \u4E2D\uFF0C\u6BCF\u4E00\u884C\u90FD\u662F\u4E00\u4E2A monadic value"}),"\n",(0,i.jsxs)(e.li,{children:["\u68C0\u67E5\u8FD4\u56DE\u503C\uFF0C\u4F7F\u7528 ",(0,i.jsx)(e.code,{children:"<-"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:'foo :: Maybe String\nfoo = do\n    x <- Just 3\n    y <- Just "!"\n    Just (show x ++ y)\n\nfoo :: Maybe String\nfoo = Just 3   >>= (\\x ->\n      Just "!" >>= (\\y ->\n      Just (show x ++ y)))\n\nroutine :: Maybe Pole\nroutine = do\n    start <- return (0,0)\n    first <- landLeft 2 start\n    Nothing\n    second <- landRight 2 first\n    landLeft 1 second\n'})}),"\n",(0,i.jsx)(e.h3,{id:"list-monad",children:"List Monad"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"non-determinism(\u4E0D\u786E\u5B9A\u6027)"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> (*) <$> [1,2,3] <*> [10,100,1000]\n[10,100,1000,20,200,2000,30,300,3000]\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u5B9E\u73B0"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Monad [] where\n    return x = [x]\n    xs >>= f = concat (map f xs)\n    fail _ = []\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u8FD4\u56DE\u503C\u4EA4\u4E92: \u4E0B\u4F8B\u4E2D n \u4E0E return (n, ch) \u8FDB\u884C\u4EA4\u4E92","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"list comprehension \u4E0E do \u8868\u793A\u6CD5 \u5747\u662F >>= \u7684\u8BED\u6CD5\u7CD6"}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(e.li,{children:["list comprehension: ",(0,i.jsx)(e.code,{children:"<-"})," \u4E0E \u6761\u4EF6\u8868\u8FBE\u5F0F"]}),"\n",(0,i.jsxs)(e.li,{children:["do \u8868\u793A\u6CD5: ",(0,i.jsx)(e.code,{children:"<-"})," \u4E0E guard \u51FD\u6570"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"ghci> [1,2] >>= \\n -> ['a','b'] >>= \\ch -> return (n,ch)\n[(1,'a'),(1,'b'),(2,'a'),(2,'b')]\n\n{- do \u8868\u793A\u6CD5 -}\nlistOfTuples :: [(Int,Char)]\nlistOfTuples = do\n    n <- [1,2]\n    ch <- ['a','b']\n    return (n,ch)\n\nsevensOnly :: [Int]\nsevensOnly = do\n    x <- [1..50]\n    guard ('7' `elem` show x)\n    return x\n\n{- list comprehension -}\nghci> [ (n,ch) | n <- [1,2], ch <- ['a','b'] ]\n[(1,'a'),(1,'b'),(2,'a'),(2,'b')]\n"})}),"\n",(0,i.jsx)(e.h3,{id:"monadplus",children:"MonadPlus"}),"\n",(0,i.jsx)(e.p,{children:"\u4F7F Monad \u5177\u6709 Monoid \u7684\u6027\u8D28(\u4E8C\u5143\u5C01\u95ED\u8FD0\u7B97)"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance MonadPlus [] where\n    mzero = []\n    mplus = (++)\n"})}),"\n",(0,i.jsx)(e.h3,{id:"monad-algorithms",children:"Monad Algorithms"}),"\n",(0,i.jsx)(e.h4,{id:"\u9A6C\u8D70\u65E5",children:"\u9A6C\u8D70\u65E5"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u8BA1\u7B97\u51FA\u53EF\u79FB\u52A8\u4F4D\u7F6E"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"moveKnight :: KnightPos -> [KnightPos]\nmoveKnight (c,r) = do\n    (c',r') <- [(c+2,r-1),(c+2,r+1),(c-2,r-1),(c-2,r+1)\n                ,(c+1,r-2),(c+1,r+2),(c-1,r-2),(c-1,r+2)\n                ]\n    guard (c' `elem` [1..8] && r' `elem` [1..8])\n    return (c',r')\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u5229\u7528 >>= \u5411\u540E\u4F20\u9012\u591A\u4E2A\u53EF\u4EA4\u4E92\u7684\u4F4D\u7F6E"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"in3 start = return start >>= moveKnight >>= moveKnight >>= moveKnight\n\nin3 :: KnightPos -> [KnightPos]\nin3 start = do\n    first <- moveKnight start\n    second <- moveKnight first\n    moveKnight second\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u6700\u540E\u5B8C\u6210\u5B8C\u6574\u51FD\u6570: \u4EA7\u751F\u6240\u6709\u4E09\u6B65\u7684\u53EF\u80FD\u4F4D\u7F6E\uFF0C\u68C0\u67E5\u5176\u4E2D\u4E00\u4E2A\u4F4D\u7F6E\u662F\u5426\u5728\u91CC\u9762"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"canReachIn3 :: KnightPos -> KnightPos -> Bool\ncanReachIn3 start end = end `elem` in3 start\n"})}),"\n",(0,i.jsx)(e.h2,{id:"foldable",children:"Foldable"}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"import qualified Data.Foldable as F\n\nfoldMap :: (Monoid m, Foldable t) => (a -> m) -> t a -> m\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance F.Foldable Tree where\n    foldMap f Empty = mempty\n    foldMap f (Node x l r) = F.foldMap f l `mappend`\n                                f x           `mappend`\n                                F.foldMap f r\n"})}),"\n",(0,i.jsx)(e.h2,{id:"data-monoid",children:"Data Monoid"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u6210\u5458: \u5FC5\u987B\u4E3A\u5177\u4F53\u7C7B\u578B (",(0,i.jsx)(e.strong,{children:"\u4E0D\u53EF\u662F\u7C7B\u578B\u6784\u9020\u7B26 (Type Constructor)"}),")."]}),"\n",(0,i.jsxs)(e.li,{children:["\u51C6\u5219 (Monoid Law):","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:[(0,i.jsx)(e.em,{children:"\u7ED3\u5408\u5F8B"})," ",(0,i.jsx)(e.code,{children:"a\xb7(b\xb7c) = (a\xb7b)\xb7c"}),"."]}),"\n",(0,i.jsxs)(e.li,{children:["\u65E0\u9700\u6EE1\u8DB3 ",(0,i.jsx)(e.code,{children:"a mappend b == b mappend a"}),"."]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"class Monoid m where\n    mempty :: m             -- identity\n    mappend :: m -> m -> m\n    mconcat :: [m] -> m\n    mconcat = foldr mappend mempty\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u5B9E\u4F8B"}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Monoid [a] where\n    mempty = []\n    mappend = (++)\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"newtype Product a =  Product { getProduct :: a }\n    deriving (Eq, Ord, Read, Show, Bounded)\n\ninstance Num a => Monoid (Product a) where\n    mempty = Product 1\n    Product x `mappend` Product y = Product (x * y)\n\nghci> getProduct $ Product 3 `mappend` Product 4 `mappend` Product 2\n24\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"newtype Any = Any { getAny :: Bool }\n    deriving (Eq, Ord, Read, Show, Bounded)\n\ninstance Monoid Any where\n    mempty = Any False\n    Any x `mappend` Any y = Any (x || y)\n\nghci> getAny . mconcat . map Any $ [False, False, False, True]\nTrue\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"newtype All = All { getAll :: Bool }\n    deriving (Eq, Ord, Read, Show, Bounded)\n\ninstance Monoid All where\n    mempty = All True\n    All x `mappend` All y = All (x && y)\n\nghci> getAll . mconcat . map All $ [True, True, False]\nFalse\n"})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Monoid Ordering where\n    mempty = EQ\n    LT `mappend` _ = LT\n    EQ `mappend` y = y\n    GT `mappend` _ = GT\n"})}),"\n",(0,i.jsx)(e.admonition,{type:"tip",children:(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:'-- mappend \u5728\u5DE6\u8FB9\u4E0D\u7B49\u4E8E EQ \u7684\u60C5\u51B5\u4E0B\u90FD\u4F1A\u56DE\u4F20\u5DE6\u8FB9\u7684\u503C\u3002\u76F8\u53CD\u5730\u5219\u56DE\u4F20\u53F3\u8FB9\u7684\u503C\n-- \u53EF\u4EE3\u66FF\u591A\u4E2A if/else \u8BED\u53E5\nimport Data.Monoid\n\nlengthCompare :: String -> String -> Ordering\nlengthCompare x y = (length x `compare` length y) `mappend`\n                    (vowels x `compare` vowels y) `mappend`\n                    (x `compare` y)\n    where vowels = length . filter (`elem` "aeiou")\n'})})}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"instance Monoid a => Monoid (Maybe a) where\n    mempty = Nothing\n    Nothing `mappend` m = m\n    m `mappend` Nothing = m\n    Just m1 `mappend` Just m2 = Just (m1 `mappend` m2)\n\ninstance Monoid (First a) where\n    mempty = First Nothing\n    First (Just x) `mappend` _ = First (Just x)\n    First Nothing `mappend` x = x\n\nghci> getFirst $ First (Just 'a') `mappend` First Nothing\nJust 'a'\n"})}),"\n",(0,i.jsx)(e.h2,{id:"customization",children:"Customization"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u521B\u5EFA\u65B0\u7C7B: ",(0,i.jsx)(e.em,{children:"\u53EF\u4EE5\u53EA\u6709\u58F0\u660E\u6CA1\u6709\u5B9E\u73B0"})]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"class ClassName where\n    defining code\n"})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u521B\u5EFA\u5DF2\u6709\u7C7B\u7684\u5B9E\u4F8B: ",(0,i.jsx)(e.em,{children:"\u5FC5\u987B\u5B9E\u73B0\u6240\u6709\u5DF2\u58F0\u660E\u51FD\u6570"}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsx)(e.li,{children:"\u4F5C\u7528\u7B49\u540C\u4E8E deriving(\u81EA\u7531\u5EA6\u66F4\u5927)"}),"\n",(0,i.jsx)(e.li,{children:"\u53EF\u4EE5\u91CD\u5199\u51FD\u6570,\u53BB\u9664\u9ED8\u8BA4\u51FD\u6570\u5904\u7406,\u8FBE\u5230\u7279\u5B9A\u76EE\u7684"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:'- \u5148\u521B\u5EFA\u65B0\u7C7B\u578B\ndata TrafficLight = Red | Yellow | Green\n\ninstance Eq TrafficLight where\n    Red == Red = True\n    Green == Green = True\n    Yellow == Yellow = True\n    _ == _ = False\n\ninstance Show TrafficLight where\n    show Red = "Red light"\n    show Yellow = "Yellow light"\n    show Green = "Green light"\n'})}),"\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u521B\u5EFA\u65B0\u7C7B\u548C\u5B9E\u73B0\u5B9E\u4F8B\u65F6,\u4F7F\u7528 class constraint","\n",(0,i.jsxs)(e.ul,{children:["\n",(0,i.jsxs)(e.li,{children:["\u53EF\u8FBE\u5230",(0,i.jsx)(e.strong,{children:"\u7C7B\u4F3C\u4E8E"}),"\u7EE7\u627F\u7684\u6548\u679C"]}),"\n",(0,i.jsx)(e.li,{children:"\u53EF\u8FBE\u5230\u9650\u5236\u7C7B\u578B\u7684\u6548\u679C"}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(e.pre,{children:(0,i.jsx)(e.code,{className:"language-haskell",children:"class (Eq a) => Num a where\n    ...\n\ninstance (Eq m) => Eq (Maybe m) where\n    Just x == Just y = x == y\n    Nothing == Nothing = True\n    _ == _ = False\n"})})]})}function o(n={}){let{wrapper:e}={...(0,a.R)(),...n.components};return e?(0,i.jsx)(e,{...n,children:(0,i.jsx)(h,{...n})}):h(n)}},30416(n,e,l){l.d(e,{R:()=>r,x:()=>d});var s=l(59471);let i={},a=s.createContext(i);function r(n){let e=s.useContext(a);return s.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function d(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:r(n.components),s.createElement(a.Provider,{value:e},n.children)}}}]);