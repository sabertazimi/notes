"use strict";(self.webpackChunknotes=self.webpackChunknotes||[]).push([["47633"],{78394(e,n,l){l.r(n),l.d(n,{metadata:()=>i,default:()=>h,frontMatter:()=>s,contentTitle:()=>d,toc:()=>c,assets:()=>a});var i=JSON.parse('{"id":"language/haskell/io","title":"I/O","description":"ByteString","source":"@site/content/language/haskell/io.md","sourceDirName":"language/haskell","slug":"/language/haskell/io","permalink":"/notes/language/haskell/io","draft":false,"unlisted":false,"editUrl":"https://github.com/sabertazimi/notes/edit/main/content/language/haskell/io.md","tags":[{"inline":true,"label":"Language","permalink":"/notes/tags/language"},{"inline":true,"label":"Haskell","permalink":"/notes/tags/haskell"},{"inline":true,"label":"I/O","permalink":"/notes/tags/i-o"}],"version":"current","lastUpdatedBy":"Sabertaz","lastUpdatedAt":1769518084000,"sidebarPosition":8,"frontMatter":{"sidebar_position":8,"tags":["Language","Haskell","I/O"]},"sidebar":"tutorialSidebar","previous":{"title":"Monad","permalink":"/notes/language/haskell/monad"},"next":{"title":"Exception","permalink":"/notes/language/haskell/exception"}}'),r=l(62615),t=l(30416);let s={sidebar_position:8,tags:["Language","Haskell","I/O"]},d="I/O",a={},c=[{value:"ByteString",id:"bytestring",level:2},{value:"File",id:"file",level:2},{value:"Handle",id:"handle",level:3},{value:"With",id:"with",level:3},{value:"Read",id:"read",level:3},{value:"Write",id:"write",level:3},{value:"Append",id:"append",level:3},{value:"Directory",id:"directory",level:3},{value:"Input",id:"input",level:2},{value:"Char",id:"char",level:3},{value:"Contents",id:"contents",level:3},{value:"Output",id:"output",level:2},{value:"String",id:"string",level:3},{value:"Print",id:"print",level:3},{value:"Action",id:"action",level:2},{value:"Return",id:"return",level:3},{value:"When",id:"when",level:3},{value:"Sequence",id:"sequence",level:3},{value:"Map",id:"map",level:3},{value:"Control",id:"control",level:3},{value:"hSetBuffering",id:"hsetbuffering",level:3},{value:"hFlush",id:"hflush",level:3},{value:"Command Line",id:"command-line",level:2},{value:"Lines",id:"lines",level:2},{value:"Interact",id:"interact",level:2}];function o(e){let n={blockquote:"blockquote",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",ul:"ul",...(0,t.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(n.header,{children:(0,r.jsx)(n.h1,{id:"io",children:"I/O"})}),"\n",(0,r.jsx)(n.h2,{id:"bytestring",children:"ByteString"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Data.ByteString"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"Data.ByteString.Lazy"})}),"\n"]}),"\n",(0,r.jsx)(n.p,{children:"lazy byteStrings \u50CF\u88C5\u4E86\u4E00\u5806\u5927\u5C0F\u4E3A 64K \u7684 strict byteStrings \u7684 list"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"import qualified Data.ByteString.Lazy as B\nimport qualified Data.ByteString as S\n"})}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"pack/unpack"}),"\n",(0,r.jsx)(n.li,{children:"fromChunks/toChunks"}),"\n",(0,r.jsx)(n.li,{children:"cons/empty/head/tail/init/null/length/map/reverse/foldl/foldr/concat/takeWhile/filter"}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"file",children:"File"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"hPutStr"})}),"\n",(0,r.jsx)(n.li,{children:(0,r.jsx)(n.code,{children:"hPutStrLn"})}),"\n"]}),"\n",(0,r.jsx)(n.h3,{id:"handle",children:"Handle"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"data IOMode = ReadMode | WriteMode | AppendMode | ReadWriteMode"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"openFile :: FilePath(String) -> IOMode -> IO Handle"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"hGetContents :: Handle -> IO String"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"hClose :: Handle -> IO ()"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"hGetChar"})}),"\n"]}),"\n",(0,r.jsxs)(n.li,{children:["\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"hGetLine"})}),"\n"]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'import System.IO\n\nmain = do\n    handle <- openFile "girlfriend.txt" ReadMode\n    contents <- hGetContents handle\n    putStr contents\n    hClose handle\n'})}),"\n",(0,r.jsx)(n.h3,{id:"with",children:"With"}),"\n",(0,r.jsx)(n.p,{children:(0,r.jsx)(n.code,{children:"withFile :: FilePath -> IOMode -> (Handle -> IO a) -> IO a"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'import System.IO\n\nmain = do\n    withFile "girlfriend.txt" ReadMode (\\handle -> do\n            contents <- hGetContents handle\n            putStr contents)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"read",children:"Read"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'contents <- readFile "girlfriend.txt"\n'})}),"\n",(0,r.jsx)(n.h3,{id:"write",children:"Write"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"writefile :: FilePath -> String -> IO ()"})," - WriteMode, not AppendMode"]}),"\n",(0,r.jsx)(n.h3,{id:"append",children:"Append"}),"\n",(0,r.jsx)(n.h3,{id:"directory",children:"Directory"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"removeFile"}),"."]}),"\n",(0,r.jsxs)(n.li,{children:[(0,r.jsx)(n.code,{children:"renameFile"}),"."]}),"\n"]}),"\n",(0,r.jsx)(n.h2,{id:"input",children:"Input"}),"\n",(0,r.jsx)(n.h3,{id:"char",children:"Char"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"getChar :: IO Char"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"main = do\n    c <- getChar\n    if c /= ' '\n        then do\n            putChar c\n            main\n        else return ()\n"})}),"\n",(0,r.jsx)(n.h3,{id:"contents",children:"Contents"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"getContents :: IO String"})," (lazy I/O),\n\u5185\u5BB9\u6682\u5B58\u5728\u6587\u4EF6, \u9700\u8981\u4F7F\u7528\u65F6\u8BFB\u53D6\u81F3\u5185\u5B58\u533A:"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"import Data.Char\n\nmain = do\n    contents <- getContents\n    putStr (map toUpper contents)\n"})}),"\n",(0,r.jsx)(n.h2,{id:"output",children:"Output"}),"\n",(0,r.jsx)(n.h3,{id:"string",children:"String"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"putChar"}),"/",(0,r.jsx)(n.code,{children:"putStr"}),"/",(0,r.jsx)(n.code,{children:"putStrLn"}),":"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"putStr :: String -> IO ()\nputStr [] = return ()\nputStr (x:xs) = do\n    putChar x\n    putStr xs\n"})}),"\n",(0,r.jsx)(n.h3,{id:"print",children:"Print"}),"\n",(0,r.jsx)(n.p,{children:"print = putStrLn . show"}),"\n",(0,r.jsx)(n.h2,{id:"action",children:"Action"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"name <- IO action"}),": \u5C06 action \u7ED1\u5B9A\u81F3\u540D\u5B57\u4E0A,IO String -> String"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"name <- getLine\nname <- return String\n\nname <- putStrLn String\n"})}),"\n",(0,r.jsxs)(n.p,{children:["\u5728\u4E00\u4E2A",(0,r.jsx)(n.code,{children:"do block"}),"\u4E2D,\u6700\u540E\u4E00\u4E2A",(0,r.jsx)(n.code,{children:"action"}),"\u4E0D\u80FD\u7ED1\u5B9A\u4EFB\u4F55\u540D\u5B57,\u5B83\u4F1A\u88AB\u7ED1\u5B9A\u6210\u4E3A",(0,r.jsx)(n.code,{children:"do block"}),"\u7684\u7ED3\u679C\u503C."]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'main = do\n    foo <- putStrLn "Hello, what\'s your name?"\n    name <- getLine\n    putStrLn ("Hey " ++ name ++ ", you rock!")\n'})}),"\n",(0,r.jsx)(n.h3,{id:"return",children:"Return"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"return \u529F\u80FD:\u5C06 pure value \u5305\u6210 I/O actions,\u4E0D\u4F1A\u7EC8\u6B62\u51FD\u6570/\u7A0B\u5E8F"}),"\n",(0,r.jsxs)(n.li,{children:["return \u4F5C\u7528:","\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"if condition then I/O action else I/O action"}),"\n",(0,r.jsxs)(n.li,{children:["\u6539\u53D8",(0,r.jsx)(n.code,{children:"do block\u5F62\u6210\u7684I/O action"}),"\u7684\u7ED3\u679C\u503C: otherIOAction -> return pureValue"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:'e.g. return "haha" - String -> IO String'}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"main = do\n    line <- getLine\n    if null line\n        then return ()\n        else do\n            putStrLn $ reverseWords line\n            main\n\nreverseWords :: String -> String\nreverseWords = unwords . map reverse . words\n"})}),"\n",(0,r.jsx)(n.h3,{id:"when",children:"When"}),"\n",(0,r.jsx)(n.p,{children:"Control.Monad.when :: (Applicative f) => Bool -> f () -> f ()"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"when bool\u8868\u8FBE\u5F0F I/O-Action"})," - \u771F\u65F6\u8FD4\u56DE Action,\u5047\u65F6",(0,r.jsx)(n.code,{children:"return ()"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"import Control.Monad\n\nmain = do\n    c <- getChar\n    when (c /= ' ') $ do\n        putChar c\n        main\n"})}),"\n",(0,r.jsx)(n.h3,{id:"sequence",children:"Sequence"}),"\n",(0,r.jsxs)(n.p,{children:["sequence :: ",(0,r.jsx)(n.code,{children:"[IO a]"})," -> IO ",(0,r.jsx)(n.code,{children:"[a]"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"main = do\n    rs <- sequence [getLine, getLine, getLine]\n    print rs\n"})}),"\n",(0,r.jsx)(n.h3,{id:"map",children:"Map"}),"\n",(0,r.jsx)(n.p,{children:"mapM, Control.Monad.forM:"}),"\n",(0,r.jsx)(n.p,{children:"= sequence . map"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"ghci> mapM print [1,2,3]\n1\n2\n3\n[(),(),()]\nghci> mapM_ print [1,2,3]\n1\n2\n3\n"})}),"\n",(0,r.jsx)(n.h3,{id:"control",children:"Control"}),"\n",(0,r.jsx)(n.p,{children:"\u63A5\u53D7\u4E00\u4E2A I/O action \u5E76\u56DE\u4F20\u4E00\u4E2A\u6C38\u8FDC\u4F5C\u540C\u4E00\u4EF6\u4E8B\u7684 I/O action"}),"\n",(0,r.jsx)(n.p,{children:"\u4EE5\u4E0B\u4EE3\u7801\u5B9E\u73B0\u4E86\u5FAA\u73AF\u7ED3\u6784:"}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'import Control.Monad\nimport Data.Char\n\nmain = forever $ do\n    putStr "Give me some input: "\n    l <- getLine\n    putStrLn $ map toUpper l\n'})}),"\n",(0,r.jsx)(n.h3,{id:"hsetbuffering",children:"hSetBuffering"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"data BufferMode = NoBuffering | LineBuffering | BlockBuffering (Maybe Int)"}),"\n",(0,r.jsx)(n.code,{children:"hSetBuffering :: Handle -> BufferMode -> IO ()"})]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'main = do\n    withFile "something.txt" ReadMode (\\handle -> do\n        hSetBuffering handle $ BlockBuffering (Just 2048)\n        contents <- hGetContents handle\n        putStr contents)\n'})}),"\n",(0,r.jsx)(n.h3,{id:"hflush",children:"hFlush"}),"\n",(0,r.jsx)(n.h2,{id:"command-line",children:"Command Line"}),"\n",(0,r.jsxs)(n.blockquote,{children:["\n",(0,r.jsx)(n.p,{children:"System.Environment"}),"\n"]}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsxs)(n.li,{children:["getArgs: ",(0,r.jsx)(n.code,{children:"getArgs :: IO [String]"})]}),"\n",(0,r.jsxs)(n.li,{children:["getProgName: ",(0,r.jsx)(n.code,{children:"getProgName :: IO String"})]}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"import System.Environment\nimport Data.List\n\nmain = do\n    args <- getArgs\n    progName <- getProgName\n    mapM putStrLn args\n    putStrLn progName\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'import System.Environment\nimport System.Directory\nimport System.IO\nimport Data.List\n\ndispatch :: [(String, [String] -> IO ())]\ndispatch =  [ ("add", add)\n            , ("view", view)\n            , ("remove", remove)\n            ]\n\nmain = do\n    (command:args) <- getArgs\n    let (Just action) = lookup command dispatch\n    action args\n\nadd :: [String] -> IO ()\nadd [fileName, todoItem] = appendFile fileName (todoItem ++ "\\n")\n\nview :: [String] -> IO ()\nview [fileName] = do\n    contents <- readFile fileName\n    let todoTasks = lines contents\n        numberedTasks = zipWith (\\n line -> show n ++ " - " ++ line) [0..] todoTasks\n    putStr $ unlines numberedTasks\n\nremove :: [String] -> IO ()\nremove [fileName, numberString] = do\n    handle <- openFile fileName ReadMode\n    (tempName, tempHandle) <- openTempFile "." "temp"\n    contents <- hGetContents handle\n    let number = read numberString\n        todoTasks = lines contents\n        newTodoItems = delete (todoTasks !! number) todoTasks\n    hPutStr tempHandle $ unlines newTodoItems\n    hClose handle\n    hClose tempHandle\n    removeFile fileName\n    renameFile tempName fileName\n'})}),"\n",(0,r.jsx)(n.h2,{id:"lines",children:"Lines"}),"\n",(0,r.jsxs)(n.p,{children:[(0,r.jsx)(n.code,{children:"lines :: String -> [String]"})," - \u6309\u6362\u884C\u7B26\u5C06\u6BB5\u843D\u5207\u5272\u6210\u53E5\u5B50"]}),"\n",(0,r.jsx)(n.h2,{id:"interact",children:"Interact"}),"\n",(0,r.jsxs)(n.ul,{children:["\n",(0,r.jsx)(n.li,{children:"arguments: String -> String \u7684\u51FD\u6570"}),"\n",(0,r.jsx)(n.li,{children:"return: \u4E00\u4E2A I/O action"}),"\n",(0,r.jsx)(n.li,{children:"function: I/O action \u4F1A\u8BFB\u53D6\u8F93\u5165\uFF0C\u8C03\u7528\u63D0\u4F9B\u7684\u51FD\u6570\uFF0C\u7136\u540E\u628A\u51FD\u6570\u7684\u7ED3\u679C\u6253\u5370\u51FA\u6765"}),"\n"]}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"main = interact shortLinesOnly\n\nshortLinesOnly :: String -> String\nshortLinesOnly input =\n    let allLines = lines input\n        shortLines = filter (\\line -> length line < 10) allLines\n        result = unlines shortLines\n    in result\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:"main = interact $ unlines . filter ((<10) . length) . lines\n"})}),"\n",(0,r.jsx)(n.pre,{children:(0,r.jsx)(n.code,{className:"language-haskell",children:'respondPalindromes = unlines . map (\\xs ->\n    if isPalindrome xs then "palindrome" else "not a palindrome") . lines\n        where isPalindrome xs = xs == reverse xs\n'})})]})}function h(e={}){let{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,r.jsx)(n,{...e,children:(0,r.jsx)(o,{...e})}):o(e)}},30416(e,n,l){l.d(n,{R:()=>s,x:()=>d});var i=l(59471);let r={},t=i.createContext(r);function s(e){let n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:s(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);